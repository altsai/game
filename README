Known bugs:
	In my gui, upon generating a path from one actor to another, each actor and film appears as a link. Clicking on them does not work, though the links may be accessed by opening them in new tabs. Hovering over the link displays a url link at the bottom left, though.

	Another small bug in my gui is on the update page; I wrote main.js with the intention that it would parse the responseJSON and display the status of the update (whether insertion/deletion was successful or not) as an alert; for some reason, however, I received inconsistent results with the alerts, with them sometimes not appearing at all.


Design details specific to your code:
	Graphs are represented as a map of vertex identifiers to the vertices themselves, thus yielding constant time retrieval and addition to the graph. Vertices, implemented as an interface, are able to take on neighbors (edges). Edges, also implemented as a an interface, must be able to convey to the user their weight and target vertex.

	Actor and Film implement Vertex and Edge, respectively. Actor contains an actor's pertinent information (name and id), as well as maps mapping neighbors' ids to the minimum weighted shared film and the neighbor vertex. Actor equality is based solely on id, as ids are unique across the database. In adding neighbors, an Actor either rejects the edge upon the basis that it shares a lesser weighted edge with the same target or swaps it out for the previous edge. Film contains the name and id of a film, its weight (the reciprocal of the number of actors starring in it), and its target (an Actor). Film equality is based upon equal ids, target, and weight.

	Main is run with command line arguments; it first uses an Option Parser to determine if the user has enaled --gui as an option. If --gui is not specified, then it instantiates a GraphLoader with the provided file. GraphLoader's functionality consists of building a graph by querying the database while simultaneously applying Dijkstra's algorithm to find the shortest path from a source to a target. To increase efficiency, GraphLoader caches film weights and film names (mapped to by a film id). As it builds the graph, it maintains distance and parent maps, mapping Actors in the graph to the shortest distance to the source node and to the previous Actor along that shortest path. Once the shortest path to the target is determined (either by emptying the priority queue or dequeuing the target node), the shortest path has been found. The shortest path is then recorded both in String format and in PathElement format, which stores each step of the path as two Actors and their connecting Film. 

	If --gui is specified, then CommandLineParser determines which argument is the database file and creates a GuiHandler. The GuiHandler establishes a connection to the database and instantiates an Autocorrector (built from a Dictionary and Trie) to be used in the interface. It then carries out whichever events the user triggers, whether that be making modifications to tables in the database (adding actors and films, adding relationships between actors and films, and removing relationships between actors and films) or finding the shortest path between two specified actors.

	The gui consists of a main page (localhost:4567/home), where a user can enter search terms (a start and a target actor) or navigate to the update page (localhost:4567/update). After conducting a search, the user has the option to run another search, navigate to the update page, or choose a movie or actor link (localhost:4567/baconresults/<id>, where forward slashes are replaced with "%20") (if valid entries were input previously). From the update page, the user can add a movie, actor, or add/remove a movie/actor relationship. Dialog boxes pop up when a user tries to enter a null entry. If fully functional, dialog boxes would have informed the user whether or not the desired update to the database was successful.

	The Autocorrector's functionality was modified to treat everything as one word; when the names were stored in the Trie, each full name was taken as one "word". Suggestions were generated first by prefix completion and then by LED distance, if there were fewer than five prefix completion suggestions.

	In selecting between actors with the same name, my program picks one arbitrarily. In determining the path between an actor and himself, there is a direct connection with no associated film.


Any runtime/space optimizations you made beyond the minimum requirements:
	None in particular, though mine does run about three times faster than the TA solution times listed on Piazza. I made an effort to optimize my queries with nested select statements and decrease runtime by caching film information (names and weight).


How to run your tests:
	JUnit tests are locaed in src/test/java, and can be run with:
		mvn clean
		mvn package

	System tests are located in system, and can be run with:
		cs032_system_tester_slow ./run system/*


Any tests you wrote and tried by hand: 
	various by a small database I created, but the copy was lost


How to build/run your program from the command line:
	mvn clean
	mvn package
	./run <start actor> <target actor> <sqlite_file>

	Actor names must be enclosed in quotation marks if they consist of multiple words separated by whitespace


Design Questions:
	1. How could you adjust your bacon project so that other developers can easily add new graph search algorithms without having to worry about other constraints of the project (e.g. structure of the database, first initial -> last initial)?

	The class involving the search algorithm is limited to GraphLoader, which interacts heavily with the database. In adding support for other developers I would transfer over more general functionality of GraphLoader to the Graph class while keeping database-specific dealings strictly in the GraphLoader. Thus the Graph would be kept fluid in its ability to adapt to other situations and constraints.

	
	2. How could you improve your code to make it able to accept multiple types of files? For example, what if you wanted your program to be able to accept both a SQL database or a number of .tsv files containing the same data?

	I would have to further abstract my classes such that interaction with the data is generic to all types of data files but one; then one class would have direct interaction with the file while the other classes were blind to the file type, interacting only with the data itself. For example, this class would take care of all of the sql querying when dealing with databases or would perform full reads/reference checks to the .tsv files, passing the results in a form that data from any file type could conform to (i.e. not ResultSets).

	
	3. What would you need to change if movies now had an associated year of release and the chain of movies had to go in chronological order? (What if the time machine exploded?)

	In querying for its neighbors, the current Actor in question would have to reference its parent (or previous) Actor in the path it's currently fixed in. By referencing its parent Actor it can determine the edge between them and thus the year of the movie between them. Then the query would include a join on film ids between actor_film and film, and limit results to those where the year of release fell at or beyond the year of release of the film the Actor shares with its parent.


Checkstyle Appeals:
	I have three counts of "Line has trailing spaces"; I did everything I could to get rid of those, including changing spacing preferences on Eclipse and rewriting the JavaDoc comments from scratch (they all occur in JavaDoc comments on empty lines).